<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · NetworkDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NetworkDynamics</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../BasicConstructors/">Functions</a></li><li><a class="tocitem" href="../parameters/">Parameter handling</a></li><li><a class="tocitem" href="../Multithreading/">Multi-Threading</a></li><li><a class="tocitem" href="../Library/">Library</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Theoretical-background-1"><span>Theoretical background</span></a></li><li><a class="tocitem" href="#Modeling-diffusion-in-NetworkDynamics.jl-1"><span>Modeling diffusion in NetworkDynamics.jl</span></a></li><li><a class="tocitem" href="#abstract_direction-1"><span>Abstract edge directions in undirected graphs</span></a></li><li><a class="tocitem" href="#Constructing-the-network-1"><span>Constructing the network</span></a></li><li><a class="tocitem" href="#Appendix:-The-network-Laplacian-L-1"><span>Appendix: The network Laplacian <span>$L$</span></span></a></li></ul></li><li><a class="tocitem" href="../directed_and_weighted_graphs/">Directed and weighted graphs</a></li><li><a class="tocitem" href="../heterogeneous_system/">Heterogeneous systems</a></li><li><a class="tocitem" href="../SDEVertex/">Stochastic differential equations</a></li><li><a class="tocitem" href="../getting_started_with_DDEs/">Delay differential equations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FHell/NetworkDynamics.jl/blob/master/docs/src/getting_started_with_network_dynamics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="getting_started-1"><a class="docs-heading-anchor" href="#getting_started-1">Network diffusion</a><a class="docs-heading-anchor-permalink" href="#getting_started-1" title="Permalink"></a></h1><p>This introductory example explains the use of the basic types and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network. A corresponding <code>IJulia</code> <a href="https://github.com/FHell/NetworkDynamics.jl/tree/master/examples">notebook</a> is available on GitHub.</p><h2 id="Theoretical-background-1"><a class="docs-heading-anchor" href="#Theoretical-background-1">Theoretical background</a><a class="docs-heading-anchor-permalink" href="#Theoretical-background-1" title="Permalink"></a></h2><p>Diffusion processes are relevant for phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed heat, charge or concentration. In such system the local temperature (or concentration) changes according to its difference with its neighborhood, i.e. the temperature gradient.</p><p>Let <span>$g$</span> be a graph with <span>$N$</span> nodes and adjacency matrix <span>$A$</span>. Let <span>$v = (v_1, \dots, v_n)$</span> be a vector of (abstract) temperatures or concentrations at each node <span>$i = 1, \dots, N$</span>. Then the rate of change of state <span>$v_i$</span> is described by its difference with its neighbors and we obtain the following ordinary differential equation</p><div>\[\dot v_i = - \sum_{i=1}^N A_{ij} (v_i - v_j).\]</div><p>The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node <span>$i$</span> is higher than at its neighboring node <span>$j$</span> it will decrease along that edge.</p><h2 id="Modeling-diffusion-in-NetworkDynamics.jl-1"><a class="docs-heading-anchor" href="#Modeling-diffusion-in-NetworkDynamics.jl-1">Modeling diffusion in NetworkDynamics.jl</a><a class="docs-heading-anchor-permalink" href="#Modeling-diffusion-in-NetworkDynamics.jl-1" title="Permalink"></a></h2><p>From the above considerations we see that in this model the nodes do not have any internal dynamics - if a node was disconnected from the rest of the network its state would never change, since then <span>$A_{ij} = 0 \; \forall j$</span> and hence <span>$\dot v_i = 0$</span>. This means that the evolution of a node depends only on the interaction with its neighbors. In NetworkDynamics.jl interactions with neighbors are described by equations for the edges.</p><pre><code class="language-julia">function diffusionedge!(e, v_s, v_d, p, t)
    # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .
    e .= v_s - v_d
    nothing
end</code></pre><p>The function <code>diffusionedge!</code> takes as inputs the current state of the edge <code>e</code>, its source vertex <code>v_s</code>, its destination vertex <code>v_d</code>, a vector of parameters <code>p</code> and the time <code>t</code>. In order to comply with the syntax of NetworkDynamics.jl we always have to define functions for static edges with exactly these arguments, eventhough we do not need <code>p</code> and <code>t</code> for the diffusion example.</p><p><code>diffusionedge!</code> is called a <strong>mutating</strong> function, since it modifies (or <em>mutates</em>) one of its inputs, namely the edge state <code>e</code>. As a convention in julia names of mutating functions end with an <code>!</code>. The use of mutating functions reduces allocations and thereby speeds up computations. After the function call the edge&#39;s value <code>e</code> equals the difference between its source and its destination vertex (i.e. the discrete gradient along that edge).</p><p>The contributions of the different edges are then summed up in each vertex.</p><pre><code class="language-julia">function diffusionvertex!(dv, v, e_s, e_d, p, t)
    # usually v, e_s, e_d are arrays, hence we use the broadcasting operator .
    dv .= 0.
    # edges for which v is the source
    for e in e_s
        dv .-= e
    end
    # edges for which v is the destination
    for e in e_d
        dv .+= e
    end
    nothing
end</code></pre><p>Just like above the input arguments <code>v, e_s, e_d, p, t</code> are mandatory for the syntax of vertex functions. The additional input <code>dv</code> corresponding to the derivative of the vertex&#39; state is mandatory for vertices described by ordinary differential equations.</p><p>Something unexpected happens in the for-loops: The contributions of the connecting edges are subtracted or added depending on <code>v</code> being the source or the destination of an edge. However we are modeling diffusion on an <strong>undirected</strong> network, hence the concepts of source and destination are not defined!</p><p>The reason for this syntax is found in the <code>LightGraphs.jl</code> package on which <code>NetworkDynamics.jl</code> is based.</p><h2 id="abstract_direction-1"><a class="docs-heading-anchor" href="#abstract_direction-1">Abstract edge directions in undirected graphs</a><a class="docs-heading-anchor-permalink" href="#abstract_direction-1" title="Permalink"></a></h2><p>LightGraphs.jl implements edges as pairs of node indices <code>i</code> and <code>j</code>. <a href="https://docs.julialang.org/en/v1/base/collections/#Base.Pair">Pairs</a> are basic julia data types consisting of two fixed elements, definded by writing <code>i =&gt; j</code>. In directed graphs these pairs additionally represent the direction in which the edge is pointing (from the first two the second element). In undirected graphs every edge is represent by only a single pair <code>i =&gt; j</code> if index <code>i</code> is smaller than index <code>j</code> and <code>j =&gt; i</code> otherwise. Hence, even for undirected graphs every edge has an abstract direction, specified by the pair of indices of the attached nodes.</p><p>A LightGraphs.jl user, who is only interested in undirected graphs, usually does not have to deal with this abstract directionality. However since NetworkDynamics.jl is interfacing directly to the underlying graph objects, we have to keep in mind that every edge has an <em>abstract direction</em> and thus a source and a destination.</p><p>In the diffusion example the coupling terms have to be modified accordingly. Assume node <span>$i$</span> is connected to node <span>$j$</span> by an undirected edge.</p><ol><li>Case: <code>i =&gt; j</code></li></ol><p>If the abstract edge direction points from <span>$i$</span> to <span>$j$</span> then the edge value will be <span>$v_i - v_j$</span>. Hence we have to subtract this term from <code>dv</code>.</p><ol><li>Case: <code>j =&gt; i</code></li></ol><p>In this case the edge value is <span>$v_j - v_i$</span>. Of course that&#39;s just <span>$-(v_i - v_j)$</span> and can be directly added to <code>dv</code>.</p><h4 id="Caveat:-Symmetric-and-asymmetric-coupling-terms-1"><a class="docs-heading-anchor" href="#Caveat:-Symmetric-and-asymmetric-coupling-terms-1">Caveat: Symmetric and asymmetric coupling terms</a><a class="docs-heading-anchor-permalink" href="#Caveat:-Symmetric-and-asymmetric-coupling-terms-1" title="Permalink"></a></h4><p>The coupling term <span>$g(i, j) := v_i - v_j$</span> is anti-symmetric, that is <span>$g(i,j) = - g(j,i)$</span> and hence multiplying some edge values with <code>-1</code> restores the behaviour of undirected edges. The same property holds for other important coupling terms like <span>$g(i,j) = \sin(v_i - v_j)$</span>. On the other hand, if the coupling term happens to be <strong>symmetric</strong>, i.e. <span>$g(i,j) = g(j,i)$</span> we don&#39;t have to worry about the abstract direction at all.</p><p>However, some coupling terms are <strong>neither symmetric nor anti-symmetric</strong> like the chemical coupling between neurons. In this case it is a viable strategy to double the number of edge variables, compute both outcomes and use only one depending on the abstract direction of the edge. For more details have a look at the example on chemical coupling.</p><h2 id="Constructing-the-network-1"><a class="docs-heading-anchor" href="#Constructing-the-network-1">Constructing the network</a><a class="docs-heading-anchor-permalink" href="#Constructing-the-network-1" title="Permalink"></a></h2><p>With the preliminaries out of the way, it only takes a few steps to assemble the network dynamics.</p><pre><code class="language-julia">using LightGraphs

N = 20 # number of nodes
k = 4  # average degree
g = barabasi_albert(N, k) # a little more exciting than a bare random graph</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> generates a scale-free random graph.</p><pre><code class="language-julia">using NetworkDynamics

nd_diffusion_vertex = ODEVertex(f! = diffusionvertex!, dim = 1)
nd_diffusion_edge = StaticEdge(f! = diffusionedge!, dim = 1)

nd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)</code></pre><p><code>ODEVertex</code>band <code>StaticEdge</code> are functions wrappers that equip the functions we defined above with additional information like <strong><code>dim</code></strong> and return objects of type <code>VertexFunction</code> and <code>EdgeFunction</code>. Then the key constructor <code>network_dynamics</code> combines them with the topological information contained in the graph <strong><code>g</code></strong> and returns an <code>ODEFunction</code> compatible with the solvers of <code>DifferentialEquations.jl</code>. The keyword <strong><code>dim</code></strong> specifies the number of variables at each edge or node.</p><pre><code class="language-julia">using OrdinaryDiffEq

x0 = randn(N) # random initial conditions
ode_prob = ODEProblem(nd, x0, (0., 4.))
sol = solve(ode_prob, Tsit5());</code></pre><p>We are solving the diffusion problem on the time interval <span>$[0, 4]$</span> with the <code>Tsit5()</code> algorithm, which is recommended  by the authors of <code>DifferentialEquations.jl</code> for most non-stiff problems.</p><pre><code class="language-julia">using Plots
plot(sol, vars = syms_containing(nd, &quot;v&quot;));</code></pre><p><img src="../diff1.svg" alt/></p><p>The plotting is straightforward. The <strong><code>vars</code></strong> keyword allows us to pass a list of indices or <em>symbols</em> specifiying the variables we want to plot. <em>Symbols</em> can be thought of as names given to the interal variables of an <code>ODEFunction</code>, much like the variables <span>$x$</span> or <span>$\phi$</span> in mathematical notation. The default symbol for vertex variables is <code>v</code>, however we are free to specify other symbols by passing them to the <code>ODEVertex</code> constructor.</p><p><code>syms_containing</code> is a helper function that returns all symbols of an <code>ODEProblem</code> containg a specific string (or symbol).</p><p>To illustrate a very simple multi-dimensional case, in the following we simulate two independent diffusions on an identical network. The first uses the symbol <code>x</code> and is started with initial conditions drawn from the standard normal distribution <span>$N(0,1)$</span>, the second uses the symbol <code>ϕ</code> with squared standard normal inital conditions.</p><p>The symbols have to be passed with the keyword <strong><code>sym</code></strong> to <code>ODEVertex</code>.</p><pre><code class="language-julia">N = 10 # number of nodes
k = 4  # average degree
g = barabasi_albert(N, k) # a little more exciting than a bare random graph

# We will have two independent diffusions on the network, hence dim = 2
nd_diffusion_vertex_2 = ODEVertex(f! = diffusionvertex!, dim = 2, sym = [:x, :ϕ])
nd_diffusion_edge_2 = StaticEdge(f! = diffusionedge!, dim = 2)
nd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)

x0_2 = vec(transpose([randn(N).^2 randn(N)])) # x ~ N(0,1)^2; ϕ ~ N(0,1)
ode_prob_2 = ODEProblem(nd_2, x0_2, (0., 3.))
sol_2 = solve(ode_prob_2, Tsit5());


# Try plotting the variables ϕ_i yourself. [To write ϕ type \phi and press TAB]
plot(sol_2, vars = syms_containing(nd_2, &quot;x&quot;));</code></pre><p><img src="../diff2.svg" alt/></p><h2 id="Appendix:-The-network-Laplacian-L-1"><a class="docs-heading-anchor" href="#Appendix:-The-network-Laplacian-L-1">Appendix: The network Laplacian <span>$L$</span></a><a class="docs-heading-anchor-permalink" href="#Appendix:-The-network-Laplacian-L-1" title="Permalink"></a></h2><p>The diffusion equation on a network can be rewritten as</p><div>\[\dot v_i  = d_i v_i - \sum_{i=1}^N A_{ij} v_j = d_i v_i - e_i^T A v          \]</div><p>where <span>$d_i$</span> is the degree of node <span>$i$</span> and <span>$e_i^T$</span> is the <span>$i$</span>-th standard basis vector. Introducing the diagonal matrix <span>$D$</span> that has the degree of node <span>$i$</span> in its <span>$i$</span>-th row and the Laplacian matrix <span>$L = D - A$</span> we arrive at</p><div>\[\dot v = e_i^T(D - A) v\]</div><p>and finally</p><div>\[\dot v = L v\]</div><p>This is a linear system of ODEs and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of <span>$L$</span>. For this reason <span>$L$</span> is an important construction in network science.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Library/">« Library</a><a class="docs-footer-nextpage" href="../directed_and_weighted_graphs/">Directed and weighted graphs »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 28 December 2020 17:35">Monday 28 December 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
